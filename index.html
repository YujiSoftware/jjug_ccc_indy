<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&display=swap');

    body { 
      font-family: 'Noto Sans JP", sans-serif';
    }
    .remark-code, .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }
    .remark-inline-code { 
      font-style: italic;
    }

    .remark-slide-content {
      font-size: 40px; /* 20px */
      padding: 0.5em 2em;
    }
    .remark-slide-content > * {
      margin: 0.25em 0;
    }
    .remark-slide-number {
      display: none; /* ページ番号 */
    }
    .remark-slide-content h1 {
      font-size:60px; /* 55px */
    }
    .remark-slide-content h2 {
      font-size:50px; /* 45px */
    }
    .remark-slide-content h3 {
      font-size:40px; /* 35px */
    }
    .remark-slide-content .highlight {
      color: darkred;
      font-weight: bold;
    }
    .remark-code {
      font-size:36px; /* 18px */
      background-color: #EFEFEF;
    }
    
    .move {
        animation: anim 0.5s ease-out;
    }
    @keyframes anim {
        0% {
            transform: translateX(300px);
        }
        100% {
            transform: translateX(0px);
        }
    }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Title

---

# Agenda

1. One
2. Two
3. Three
--

4. Four
5. Five
6. Six

---

# 日本語テスト（こころ・夏目漱石/著）

* 私はその人を常に先生と呼んでいた。
* だからここでもただ先生と書くだけで本名は打ち明けない。
* これは世間を憚かる遠慮というよりも、その方が私にとって自然だからである。
* 私はその人の記憶を呼び起すごとに、すぐ「先生」といいたくなる。
* 筆を執っても心持は同じ事である。
* よそよそしい頭文字などはとても使う気にならない。

---

# Transform

Java のどこで InvokeDynamic が使われている？（Java22時点）

--

.move[
* Lambda
* Pattern Matching for switch
* Recod class
  * toString, hashCode, equals メソッドの実装
* String Concatenation（Java 9〜） <!-- https://openjdk.org/jeps/280 -->
  * +演算子による文字列結合
* Refrection API（Java 18 〜）<!-- https://openjdk.org/jeps/416 -->
]

---

# Code

ソースコードのサンプル
```java
public boolean isOdd(java.util.List<java.lang.Integer>);
  0: aload_1
  1: invokeinterface #7,  1
            // InterfaceMethod java/util/List.stream:()Ljava/util/stream/Stream;
* 6: invokedynamic #13,  0
            // InvokeDynamic #0:test:()Ljava/util/function/Predicate;
 11: invokeinterface #17,  2
            // InterfaceMethod java/util/stream/Stream.allMatch:(Ljava/util/function/Predicate;)Z
 16: ireturn
```

---

class: center, middle

# indy の動作

---

# バイトコードのメソッド呼び出し命令

メソッド呼び出し(invoke)命令は5つある

* invoke**interface**
* invoke**virtual**
* invoke**static**
* invoke**special**
* invoke**dynamic**

<br>
この違いは、**メソッドの解決方法**

---

# 命令ごとのメソッド解決の違い

* invoke**interface**
  * **JVMが** 実装クラスとその親クラスから探す
* invoke**virtual**
  * **JVMが** 指定されたクラスとその親クラスから探す
* invoke**static**
  * **JVMが** 指定されたクラスから static メソッドを探す
* invoke**special**
  * **JVMが** 指定されたクラスから探す

---

# invokedynamic (indy) の場合

1. 登録された Java の **Bootstrap メソッド**を呼び出す
2. 解決処理を行い **CallSite (実行メソッド)** を JVM に渡す
3. JVM はその CallSite を実行する

<br>
Bootstrap メソッドを呼ぶのは最初の一回だけ  
以降は、CallSite を使いまわす
* オーバーヘッドがない  
* インライン化など、JVM が処理を最適化できる

---

# Bootstrapメソッドでできること

なんでもできる！

* Lookup クラスを使って、既存のメソッドを探す
* 複数のメソッドを合成する
* 条件によって渡すメソッドを変える
* その場でメソッドを作る
* 引数に応じて CallSite をアップデートする
* etc...

---

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightLines: true,
        highlightStyle: "googlecode",
        ratio: '16:9'
      });
    </script>
  </body>
</html>
