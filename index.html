<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&display=swap');

    body { 
      font-family: 'Noto Sans JP", sans-serif';
    }
    .remark-code, .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }
    .remark-inline-code { 
      font-style: italic;
    }

    .remark-slide-content {
      font-size: 40px; /* 20px */
      padding: 0.5em 2em;
    }
    .remark-slide-content > * {
      margin: 0.25em 0;
    }
    .remark-slide-number {
      display: none; /* ページ番号 */
    }
    .remark-slide-content h1 {
      font-size:60px; /* 55px */
    }
    .remark-slide-content h2 {
      font-size:50px; /* 45px */
    }
    .remark-slide-content h3 {
      font-size:40px; /* 35px */
    }
    .remark-code {
      font-size:36px; /* 18px */
      background-color: #EFEFEF;
    }
    
    .move {
        animation: anim 0.5s ease-out;
    }
    @keyframes anim {
        0% {
            transform: translateX(300px);
        }
        100% {
            transform: translateX(0px);
        }
    }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# InvokeDynamic,
# Under the Hood

<!-- Agenda はあえて出さない -->

---
class: center, middle

# javap <span style="font-size: 24pt;">してますか?</span>

---

# javap

- クラスファイル解析ツール
 - クラスやメソッドの情報抽出
 - バイトコード解析

---

```Java
public class Foo {
  public static void main(String... args) {
    System.out.println("ABC" + "DEF");
  }
}
```

コンパイルして、javapしてみると...

--

```console
> javac Foo.java

> javap Foo
Compiled from "Foo.java"
public class Foo {
  public Foo();
  public static void main(java.lang.String...);
}
```

---

```console
> javap -c Foo           -c: 逆コンパイルオプション
Compiled from "Foo.java"
public class Foo {
  public Foo();
    Code:
       0: aload_0
       1: invokespecial #1  // Method "init":()V
       4: return

  public static void main(java.lang.String...);
    Code:
       0: getstatic     #7  // Field System.out
       3: ldc           #13 // String ABCDEF
       5: invokevirtual #15 // Method println:(LString;)V
       8: return
}
```

---

<span style="width: 50%; height: 200px; position: absolute; top: 65%; left: 50%; color: darkorange;">コンパイル時にリテラル連結</span>

```console
> javap -c Foo           -c: 逆コンパイルオプション 
Compiled from "Foo.java"
public class Foo {
  public Foo();
    Code:
       0: aload_0
       1: invokespecial #1  // Method "init":()V
       4: return

  public static void main(java.lang.String...);
    Code:
       0: getstatic     #7  
*      3: ldc           #13 // String ABCDEF
       5: invokevirtual #15 // Method println:(LString;)V
       8: return
}
```

---

<span style="width: 50%; height: 200px; position: absolute; top: 32%; left: 50%; color: darkorange;">invokeXXXでメソッドコール</span>

```console
> javap -c Foo           -c: 逆コンパイルオプション 
Compiled from "Foo.java"
public class Foo {
  public Foo();
    Code:
       0: aload_0
*      1: invokespecial #1  // Method "init":()V
       4: return

  public static void main(java.lang.String...);
    Code:
       0: getstatic     #7  // Field System.out
       3: ldc           #13 // String ABCDEF
*      5: invokevirtual #15 // Method println:(LString;)V
       8: return
}
```

---

では、これでは

```Java
public class Foo {
  public static void main(String... args) {
    var x = "ABC";
    var y = "DEF";
    System.out.println(x + y);
  }
}
```

---

```console
> javap -c Foo
  ...

  public static void main(java.lang.String...);
    Code:
       0: ldc           #7  // String ABC
       2: astore_1
       3: ldc           #7  // String DEF
       5: astore_2
       6: getstatic     #9  // Field System.out
       9: aload_1
      10: aload_2
*     11: invokedynamic #15,  0
      16: invokevirtual #19 // Method println:(LString;)V
      19: return
}
```

---

class: center

### &nbsp;
### &nbsp;
### メソッドコールをしていないのに
### invokeで始まるバイトコード???

--

# 本日の主役: invokeDynamic

---

## invokeDynamic

- あとから追加された唯一のバイトコード (Java 7)

--
- メソッドコール用バイトコード
  - invokeVirtual: インスタンスメソッド
  - invokeStatic: クラスメソッド
  - invokeInterface: インタフェース定義メソッド
  - invokeSpecial: コンストラクタなど

--
  - **invokeDynamic: 動的メソッドディスパッチ**

--

<div style="font-size: 48px; font-weight: bold; text-align: center;">どういうこと?</div>

---

## 時はさかのぼって...

- 2000年代初頭: JVM言語の興隆

--

<table style="border: none; width: 80%; margin-left: 20%; margin-right: 10%;">
  <tr>
    <td>JRuby</td>
    <td>Jython</td>
  </tr>
  <tr>
    <td>Scala</td>
    <td>Rhino (JavaScript)</td>
  </tr>
  <tr>
    <td>Groovy</td>
    <td>et al.</td>
  </tr>
</table>

--

&nbsp;

- 静的型付け言語だとバイトコードに割り当てやすい
- 問題は動的型付けの言語

---
## 動的型付け言語におけるメソッドコール

- 型が実行時にならないと決まらない
  - コールするメソッドも実行時にならないと決まらない

<table style="width: 90%; margin-left: 10%;">
  <tr>
    <td style="width: 35%;">&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>x.do(a, b);</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
</table>

---
## 動的型付け言語におけるメソッドコール

- 型が実行時にならないと決まらない
  - コールするメソッドも実行時にならないと決まらない

<table style="width: 90%; margin-left: 10%;">
  <tr>
    <td style="width: 35%;">&nbsp;</td>
    <td>Foo.do(int a, int b) {...}</td>
  </tr>
  <tr>
    <td>x.do(a, b);</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td style="color: orange;">xはFoo? Bar?</td>
    <td>Bar.do(String a, String b) {...}</td>
  </tr>
</table>

--

- 実行時にコールするメソッドを決定

--
<span style="width: 80px; height: 60px; position: absolute; top: 77%; left: 20%;"><image src="images/arrow.png" /></span>

<span style="width: 500px; height: 60px; position: absolute; top: 77%; left: 30%;">動的メソッドディスパッチ</span>

---

## そこで動いたのが...

--

<table style="width: 90%; margin-left: 5%; border: none; text-align: center;">
  <tr>
    <td style="width: 40%;"><image style="width: 360px;" src="images/nutter.jpg" /></td>
    <td style="width: 45%;">&nbsp;</td>
  </tr>
  <tr>
    <td style="width: 40%; font-size: 24pt;">JRuby作者 Charles Nutter</td>
    <td style="width: 45%; font-size: 24pt;">&nbsp;</td>
  </tr>
</table>

---

## そこで動いたのが...

<table style="width: 90%; margin-left: 5%; border: none; text-align: center;">
  <tr>
    <td style="width: 40%;"><image style="width: 360px;" src="images/nutter.jpg" /></td>
    <td style="width: 45%;"><image style="width: 360px;" src="images/rose.jpg" /></td>
  </tr>
  <tr>
    <td style="width: 40%; font-size: 24pt;">JRuby作者 Charles Nutter</td>
    <td style="width: 45%; font-size: 24pt;">John Rose (Sun, 現Oracle)</td>
  </tr>
</table>

---
## Da Vince Machine Project

- JVMをJava以外の言語にも拡張するプロジェクト
  - 2007年に活動開始  

--
  - Project Lead: John Rose

--

&nbsp;<br />

<table style="width: 90%; margin-left: 5%; margin-right: 5%; text-align: left; vertical-align: top;">
  <tr>
    <td colspan="2" style="width: 20%; vertical-align: top;">JSR 292: </td>
    <td style="width: 80%;  vertical-align: top;">Supporting Dynamically Typed Languageon the Java Platform</td>
  </tr>
  <tr>
    <td style="width: 10%">&nbsp;</td>
    <td colspan="2">2011年 invokeDynamic 導入 (Java 7)</td>
  </tr>
</table>

---

## ちょっと脱線: JVM Language Summit

- Da Vince Project主催のJVMに特化したカンファレンス
  - 2008年から開催
  - 当初は **JVM Language** のサミット
  - 現在は **JVM** と **Language** のサミット

---

## ちょっと脱線: JVM Language Summit

- Da Vince Project主催のJVMに特化したカンファレンス
  - 2008年から開催
  - 当初は **JVM Language** のサミット
  - 現在は **JVM** と **Language** のサミット
  - 2024年は 8月4日から3日間<br />Oracleサンタクララキャンパスで開催

---

# 日本語テスト（こころ・夏目漱石/著）

* 私はその人を常に先生と呼んでいた。
* だからここでもただ先生と書くだけで本名は打ち明けない。
* これは世間を憚かる遠慮というよりも、その方が私にとって自然だからである。
* 私はその人の記憶を呼び起すごとに、すぐ「先生」といいたくなる。
* 筆を執っても心持は同じ事である。
* よそよそしい頭文字などはとても使う気にならない。

---

# Transform

Java のどこで InvokeDynamic が使われている？（Java22時点）

--

.move[
* Lambda
* String concat （+ 演算子による文字列結合）
* Pattern Matching for switch
* Recod class
  * toString, hashCode, equals メソッドの実装）
]

---

# Code

ソースコードのサンプル
```java
public boolean isOdd(java.util.List<java.lang.Integer>);
  0: aload_1
  1: invokeinterface #7,  1
            // InterfaceMethod java/util/List.stream:()Ljava/util/stream/Stream;
* 6: invokedynamic #13,  0
            // InvokeDynamic #0:test:()Ljava/util/function/Predicate;
 11: invokeinterface #17,  2
            // InterfaceMethod java/util/stream/Stream.allMatch:(Ljava/util/function/Predicate;)Z
 16: ireturn
```

---
class: center, middle

# ラムダ式と invokedynamic

---

# ラムダ式と invokedynamic

<!-- [内部動作に迫る：Javaのラムダ式は実際にはどのようにして動いているのか](https://blogs.oracle.com/otnjp/post/behind-the-scenes-how-do-lambda-expressions-really-work-in-java-ja) -->

* ラムダ式は、invokedynamic を使って呼び出される
* この動きを追ってみましょう！

## 検証に使用するコード

リストの中身がすべて奇数かどうか判定するメソッド
```java
public boolean isOdd(List<Integer> values) {
*    return values.stream().allMatch(v -> v % 2 == 1);
}
```

Note: `allMatch` のシグネチャ
```java
boolean allMatch(Predicate<? super T> predicate)
```

---

# コンパイル結果

`javac` でコンパイルして、`javap` でリバースアセンブルする  
（private メソッドも対象にするため、`-p` をつける）

```sh
javac Lambda.java
javap -p Lambda.class
```

--

## javap の結果
```java
public boolean isOdd(java.util.List<java.lang.Integer>);
*private static boolean lambda$isOdd$0(java.lang.Integer);
```

* コンパイルにより、`lambda$isOdd$0` というメソッドができあがる
  * ラムダ式の中身がメソッドになっている
* この2つのメソッドの関係は？

<!--
* static メソッドになる場合
  * ラムダ内で完結している
  * ラムダ内でローカル変数を使用している
* インスタンスメソッドになる場合
  * ラムダ内でフィールド変数を使用している
  * ラムダ内でクラスのインスタンスメソッドを呼んでいる
-->

---

# isOdd のバイトコード

```java
public boolean isOdd(List<Integer> values) {
*    return values.stream().allMatch(v -> v % 2 == 1);
}
```

↓

```java
 public boolean isOdd(java.util.List<java.lang.Integer>);
    0: aload_1
    1: invokeinterface #7,  1
              // InterfaceMethod java/util/List.stream:()Ljava/util/stream/Stream;
*   6: invokedynamic #13,  0
              // InvokeDynamic #0:test:()Ljava/util/function/Predicate;
   11: invokeinterface #17,  2
              // InterfaceMethod java/util/stream/Stream.allMatch:(Ljava/util/function/Predicate;)Z
   16: ireturn
```

* `isOdd` には `lambda$isOdd$0` を呼び出している箇所がない
* invokedynamic によって呼び出す処理が作られている？

---

# Boostrap に渡す内容

```java
 BootstrapMethods:
   0: #49 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:
       (
         Ljava/lang/invoke/MethodHandles$Lookup;
         Ljava/lang/String;
         Ljava/lang/invoke/MethodType;
         Ljava/lang/invoke/MethodType;
         Ljava/lang/invoke/MethodHandle;
         Ljava/lang/invoke/MethodType;
       )Ljava/lang/invoke/CallSite;
     Method arguments:
       #43 (Ljava/lang/Object;)Z
*      #45 REF_invokeStatic Lambda.lambda$isOdd$0:(Ljava/lang/Integer;)Z
       #48 (Ljava/lang/Integer;)Z
```

* `REF_invokeStatic lambda$isOdd$0` を Boostrap に渡している
* これを Bootstrap ではどう扱っている？

---

# Bootstrap の処理

* `InnerClassLambdaMetafactory` で**インナークラスを生成している**

```java
 public static CallSite metafactory(MethodHandles.Lookup caller,
                                     String interfaceMethodName,
                                     MethodType factoryType,
                                     MethodType interfaceMethodType,
                                     MethodHandle implementation,
                                     MethodType dynamicMethodType)
         throws LambdaConversionException {
     AbstractValidatingLambdaMetafactory mf;
*    mf = new InnerClassLambdaMetafactory(Objects.requireNonNull(caller),
                                           Objects.requireNonNull(factoryType),
                                           Objects.requireNonNull(interfaceMethodName),
                                           Objects.requireNonNull(interfaceMethodType),
                                           Objects.requireNonNull(implementation),
                                           Objects.requireNonNull(dynamicMethodType),
                                           false,
                                           EMPTY_CLASS_ARRAY,
                                           EMPTY_MT_ARRAY);
     mf.validateMetafactoryArgs();
     return mf.buildCallSite();
 }
```

---

# 生成されたクラスの内容

* `java.lang.invoke.LambdaMetafactory` には、**生成したクラスを出力してくれる機能**がある
  * 実行時に `-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles` を指定
* これを使えば、簡単に結果がわかる

--

出力されたクラスファイルを逆コンパイルした結果：

```java
import java.util.function.Predicate;

final class Lambda$$Lambda implements Predicate {
   private Lambda$$Lambda() {
   }

   public boolean test(Object var1) {
      return Lambda.lambda$isOdd$0((Integer)var1);
   }
}
```

---

# Bootstrap 解決後のコード

* 新たに**関数型インタフェースを実装したクラス**が作られる
  * 今回の場合は、`java.util.function.Predicate` を実装したクラス
  * このクラスの役割は、コンパイル時に作られたメソッドを呼ぶだけ
* このクラスを作る処理は初回だけで、以降はスキップ
<!-- 矢印を引いてわかりやすくする -->

```java
public boolean isOdd(List<Integer> values) {
    return values.stream().allMatch(Lambda$$Lambda().instance);
}

final class Lambda$$Lambda implements Predicate {            
  public boolean test(Object var1) {
      return Lambda.lambda$isOdd$0((Integer)var1);
  }
}

private static boolean lambda$isOdd$0(Integer v){
  return v % 2 ==0;
}
```

※ 今回の場合、`Lambda$$Lambda` は毎回 `new` せず使いまわす

---

# ほかのパターン

ラムダ式の内容によって、生成されるメソッドやクラスの構造が変わる

* ラムダ内で**フィールド変数**を参照している
  * `lambda$isOdd$0` が**インスタンスメソッド**になる
    * 今回は、参照していないので static メソッドだった
* ラムダ内で**ローカル変数**を参照している
  * コンストラクタで変数をキャプチャするクラスが生成される
  * ラムダを実行するごとに、クラスを毎回 `new` する

ラムダを書いたときに、 javap したり `-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles` をつけて処理を確認してみよう！



    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightLines: true,
        highlightStyle: "googlecode",
        ratio: '16:9'
      });
    </script>
  </body>
</html>
