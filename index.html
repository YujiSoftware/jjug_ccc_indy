<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&display=swap');

    body { 
      font-family: 'Noto Sans JP", sans-serif';
    }
    .remark-code, .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }
    .remark-inline-code { 
      font-style: italic;
    }

    .remark-slide-content {
      font-size: 40px; /* 20px */
      padding: 0.5em 2em;
    }
    .remark-slide-content > * {
      margin: 0.25em 0;
    }
    .remark-slide-number {
      display: none; /* ページ番号 */
    }
    .remark-slide-content h1 {
      font-size:60px; /* 55px */
    }
    .remark-slide-content h2 {
      font-size:50px; /* 45px */
    }
    .remark-slide-content h3 {
      font-size:40px; /* 35px */
    }
    .remark-slide-content .highlight {
      color: darkred;
      font-weight: bold;
    }
    .remark-code {
      font-size:36px; /* 18px */
      background-color: #EFEFEF;
    }

    table.border,
    table.border th,
    table.border td {
      padding: 0 0.2em;
      border: 3px solid #444;
      border-collapse: collapse;
    }
    
    .move {
        animation: anim 0.5s ease-out;
    }
    @keyframes anim {
        0% {
            transform: translateX(300px);
        }
        100% {
            transform: translateX(0px);
        }
    }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Title

---

# Agenda

1. One
2. Two
3. Three
--

4. Four
5. Five
6. Six

---

# 日本語テスト（こころ・夏目漱石/著）

* 私はその人を常に先生と呼んでいた。
* だからここでもただ先生と書くだけで本名は打ち明けない。
* これは世間を憚かる遠慮というよりも、その方が私にとって自然だからである。
* 私はその人の記憶を呼び起すごとに、すぐ「先生」といいたくなる。
* 筆を執っても心持は同じ事である。
* よそよそしい頭文字などはとても使う気にならない。

---

# Transform

Java のどこで InvokeDynamic が使われている？（Java22時点）

--

.move[
* Lambda
* Pattern Matching for switch
* Recod class
  * toString, hashCode, equals メソッドの実装
* String Concatenation（Java 9〜） <!-- https://openjdk.org/jeps/280 -->
  * +演算子による文字列結合
* Refrection API（Java 18 〜）<!-- https://openjdk.org/jeps/416 -->
]

---

# Code

ソースコードのサンプル
```java
public boolean isOdd(java.util.List<java.lang.Integer>);
  0: aload_1
  1: invokeinterface #7,  1
            // InterfaceMethod java/util/List.stream:()Ljava/util/stream/Stream;
* 6: invokedynamic #13,  0
            // InvokeDynamic #0:test:()Ljava/util/function/Predicate;
 11: invokeinterface #17,  2
            // InterfaceMethod java/util/stream/Stream.allMatch:(Ljava/util/function/Predicate;)Z
 16: ireturn
```

---

class: center, middle

# invoke 命令の基本的な動作

---

# メソッドコール用のバイトコード

* invoke**virtual**
* invoke**static**
* invoke**interface**
* invoke**special**
* invoke**dynamic** ← 🆕

何が違う？  
なんで追加した？

---

# invoke**virtual** の場合

指定された**クラスまたはその親クラス**にある  
メソッドを探して実行

<br>
```java
  foo.do(1, 2);
    ↓
  invokevirtual #10
      // #10 Method Foo.do:(int, int)V
```

---

# invoke**static** の場合

指定されたクラスにある    
**static メソッド**を探して実行

<br>
```java
  Foo.do(1, 2);
    ↓
  invokestatic #10
      // #10 Method Foo.do:(int, int)V
```

---

# invoke**interface** の場合

指定されたインタフェースの**インスタンス**にある  
メソッドを探して実行

<br>
```java
  foo.do(1, 2);
    ↓
  invokeinterface #10
      // #10 InterfaceMethod Foo.do:(int, int)V
```

---

# invoke**special** の場合

指定されたクラスにある  
メソッドを探して実行  
（コンストラクタや親クラスのメソッドなど）

<br>
```java
  super.do(1, 2);
    ↓
  invokespecial #10
      // #10 Method Foo.do:(int, int)V
```

---

class: center, middle

invoke**virtual**  
invoke**static**  
invoke**interface**  
invoke**special**  
&nbsp; 

## これだけでいいのでは？

---

# invokedynamic を使う場面

* invokevirtual / interface / static / special では  
対応できないとき

&nbsp;
<table style="width: 90%; margin-left: 10%;">
  <tr>
    <td style="width: 35%;">&nbsp;</td>
    <td>Foo.do(int a, int b) {...}</td>
  </tr>
  <tr>
    <td>x.do(a, b);</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td style="color: orange;">xはFoo? Bar?</td>
    <td>Bar.do(String a, String b) {...}</td>
  </tr>
</table>

---

# 既存の invoke 命令の制限

指定されたクラスやインタフェースから探して実行  
→ **指定しなくてはいけない**

&nbsp;  
実行時のオブジェクトによって、  
**Foo クラス or  Bar クラスのメソッド**  
を実行ということができない

&nbsp;  
でも、このようなことは動的型付け言語では必須！

---

# 簡単な解決方法

中間処理を作る

```java
public static void do(Object r, int x, int y) {
  if (r instanceof Foo) {
    Foo.do(x, y)
  } else if (r instanceof Bar) {
    Bar.do(x, y)
  }
}
```

→ これでも問題がある

---

# 問題点

1. 普通のメソッド呼び出しに比べて遅い
2. 動的に変更できない

```java
public static void do(Object r, int x, int y) {
  if (r instanceof Foo) {
    Foo.do(x, y)
  } else if (r instanceof Bar) {
    Bar.do(x, y)
  } else {
    // 別のクラスの do が呼ばれた場合は？
  }
}
```

---

# 新しい invoke 命令に求められること

1. **任意のメソッド**を実行できる
2. 十分に**速い**
3. 動的に**処理を変更できる**

--

&nbsp;   
<div style="color: darkred; font-size: 70px; text-align: center;">それが invokedynamic ！</div>

---

# invokedynamic の特徴 (1)

&nbsp;  
.center.middle[
**<span style="text-decoration: underline;">任意のメソッド</span>**を実行  
]

---

# invokedynamic の特徴 (1)

&nbsp;  
.center[
**<span style="text-decoration: underline;">任意のメソッド</span>**を実行  
↓  
実行するメソッドを決めるためのメソッドを用意する
（**Bootstrap メソッド**）
]

---

# Bootstrap メソッドの役割

<span style="text-decoration: underline">与えられた情報</span>をもとに、<span style="text-decoration: underline">実行情報(CallSite)</span>を返す  
<span style="margin-left: 3em">↓</span>
* 引数の数と型情報
* 戻り値の型情報
* メソッド検索(Lookup)クラス
* 追加情報 <!-- recipe-->

&nbsp;  
どうやって実行情報を用意する？

---

# invokedynamic の特徴 (2)

十分に**速い**  
&nbsp;  
## 理由

一回目の実行時は、  
Bootstrap メソッドから実行情報を取得   
<span style="margin-left: 4em">↓</span>  
二回目以降は、実行情報が更新されていなければ   
メソッドを実行するだけ （= invokevirtual と同じ）

---

# invokedynamic の特徴 (3)

動的に**処理を変更できる**

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        highlightLines: true,
        highlightStyle: "googlecode",
        ratio: '16:9'
      });
    </script>
  </body>
</html>
